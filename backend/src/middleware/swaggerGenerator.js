/**
 * SwaggerGenerator - Generates OpenAPI 3.0 specification from database schema
 * Creates comprehensive API documentation including all CRUD and relationship endpoints
 */
class SwaggerGenerator {
  constructor(connectionId, schema) {
    this.connectionId = connectionId;
    this.schema = schema;
  }

  /**
   * Generate complete OpenAPI specification
   * @returns {object} OpenAPI 3.0 specification
   */
  generate() {
    const spec = {
      openapi: '3.0.0',
      info: {
        title: `Auto-Generated API for ${this.connectionId}`,
        version: '1.0.0',
        description: 'REST API automatically generated from PostgreSQL database schema',
      },
      servers: [
        {
          url: '/api',
          description: 'API Server',
        },
      ],
      paths: {},
      components: {
        schemas: {},
      },
    };

    // Generate schemas and paths for each table
    for (const [tableName, tableSchema] of Object.entries(this.schema)) {
      this.generateTableSchemas(spec, tableName, tableSchema);
      this.generateTablePaths(spec, tableName, tableSchema);
    }

    return spec;
  }

  /**
   * Generate schemas for a table
   * @param {object} spec - OpenAPI spec object
   * @param {string} tableName - Table name
   * @param {object} tableSchema - Table schema
   */
  generateTableSchemas(spec, tableName, tableSchema) {
    const schemaName = this.capitalize(tableName);
    const properties = {};
    const required = [];

    // Columns to exclude from input schemas (auto-generated fields)
    const autoGeneratedColumns = new Set();

    for (const column of tableSchema.columns) {
      properties[column.name] = this.mapColumnToSwaggerType(column);
      
      // Mark as required if not nullable and no default
      if (!column.nullable && !column.default) {
        required.push(column.name);
      }

      // Identify auto-generated columns
      if (column.default) {
        // Serial/sequence columns
        if (column.default.includes('nextval')) {
          autoGeneratedColumns.add(column.name);
        }
        // Timestamp defaults
        if (column.default.toLowerCase().includes('now()') || 
            column.default.toLowerCase().includes('current_timestamp')) {
          autoGeneratedColumns.add(column.name);
        }
      }
      
      // Primary keys are often auto-generated
      if (tableSchema.primaryKeys?.includes(column.name) && 
          (column.type === 'integer' || column.type === 'bigint')) {
        autoGeneratedColumns.add(column.name);
      }
    }

    spec.components.schemas[schemaName] = {
      type: 'object',
      properties: properties,
    };

    if (required.length > 0) {
      spec.components.schemas[schemaName].required = required;
    }

    // Create input schema (without auto-generated fields)
    const inputProperties = {};
    for (const column of tableSchema.columns) {
      if (!autoGeneratedColumns.has(column.name)) {
        inputProperties[column.name] = this.mapColumnToSwaggerType(column);
      }
    }

    spec.components.schemas[`${schemaName}Input`] = {
      type: 'object',
      properties: inputProperties,
    };
  }

  /**
   * Generate API paths for a table
   * @param {object} spec - OpenAPI spec object
   * @param {string} tableName - Table name
   * @param {object} tableSchema - Table schema
   */
  generateTablePaths(spec, tableName, tableSchema) {
    const schemaName = this.capitalize(tableName);
    const basePath = `/${this.connectionId}/${tableName}`;
    const primaryKey = tableSchema.primaryKeys[0] || 'id';

    // GET /api/:connection/:table - List all
    spec.paths[basePath] = {
      get: {
        tags: [tableName],
        summary: `List all ${tableName}`,
        description: `Retrieve all records from ${tableName} with optional filtering, pagination, and sorting`,
        parameters: [
          {
            name: 'limit',
            in: 'query',
            schema: { type: 'integer', default: 100 },
            description: 'Maximum number of records to return',
          },
          {
            name: 'offset',
            in: 'query',
            schema: { type: 'integer', default: 0 },
            description: 'Number of records to skip',
          },
          {
            name: 'orderBy',
            in: 'query',
            schema: { type: 'string' },
            description: 'Column name to sort by',
          },
          {
            name: 'orderDir',
            in: 'query',
            schema: { type: 'string', enum: ['ASC', 'DESC'], default: 'ASC' },
            description: 'Sort direction',
          },
          ...this.generateFilterParameters(tableSchema),
        ],
        responses: {
          200: {
            description: 'Successful response',
            content: {
              'application/json': {
                schema: {
                  type: 'array',
                  items: { $ref: `#/components/schemas/${schemaName}` },
                },
              },
            },
          },
          500: { description: 'Server error' },
        },
      },
      post: {
        tags: [tableName],
        summary: `Create new ${tableName.slice(0, -1)}`,
        description: `Create a new record in ${tableName}`,
        requestBody: {
          required: true,
          content: {
            'application/json': {
              schema: { $ref: `#/components/schemas/${schemaName}Input` },
            },
          },
        },
        responses: {
          201: {
            description: 'Record created',
            content: {
              'application/json': {
                schema: { $ref: `#/components/schemas/${schemaName}` },
              },
            },
          },
          400: { description: 'Invalid input' },
          500: { description: 'Server error' },
        },
      },
    };

    // GET /api/:connection/:table/:id - Get by ID
    spec.paths[`${basePath}/{id}`] = {
      get: {
        tags: [tableName],
        summary: `Get ${tableName.slice(0, -1)} by ID`,
        description: `Retrieve a single record from ${tableName} by primary key`,
        parameters: [
          {
            name: 'id',
            in: 'path',
            required: true,
            schema: { type: 'string' },
            description: `${primaryKey} of the record`,
          },
        ],
        responses: {
          200: {
            description: 'Successful response',
            content: {
              'application/json': {
                schema: { $ref: `#/components/schemas/${schemaName}` },
              },
            },
          },
          404: { description: 'Record not found' },
          500: { description: 'Server error' },
        },
      },
      put: {
        tags: [tableName],
        summary: `Update ${tableName.slice(0, -1)}`,
        description: `Update a record in ${tableName}`,
        parameters: [
          {
            name: 'id',
            in: 'path',
            required: true,
            schema: { type: 'string' },
            description: `${primaryKey} of the record`,
          },
        ],
        requestBody: {
          required: true,
          content: {
            'application/json': {
              schema: { $ref: `#/components/schemas/${schemaName}Input` },
            },
          },
        },
        responses: {
          200: {
            description: 'Record updated',
            content: {
              'application/json': {
                schema: { $ref: `#/components/schemas/${schemaName}` },
              },
            },
          },
          404: { description: 'Record not found' },
          400: { description: 'Invalid input' },
          500: { description: 'Server error' },
        },
      },
      delete: {
        tags: [tableName],
        summary: `Delete ${tableName.slice(0, -1)}`,
        description: `Delete a record from ${tableName}`,
        parameters: [
          {
            name: 'id',
            in: 'path',
            required: true,
            schema: { type: 'string' },
            description: `${primaryKey} of the record`,
          },
        ],
        responses: {
          200: { description: 'Record deleted' },
          404: { description: 'Record not found' },
          500: { description: 'Server error' },
        },
      },
    };

    // Generate relationship endpoints
    this.generateRelationshipPaths(spec, tableName, tableSchema, basePath);
  }

  /**
   * Generate relationship endpoint paths
   * @param {object} spec - OpenAPI spec object
   * @param {string} tableName - Table name
   * @param {object} tableSchema - Table schema
   * @param {string} basePath - Base path for the table
   */
  generateRelationshipPaths(spec, tableName, tableSchema, basePath) {
    const primaryKey = tableSchema.primaryKeys[0] || 'id';

    // Foreign key relationships (belongs-to)
    for (const fk of tableSchema.foreignKeys || []) {
      const relatedTable = fk.foreignTable;
      const relatedSchema = this.capitalize(relatedTable);
      const path = `${basePath}/{id}/${relatedTable}`;

      spec.paths[path] = {
        get: {
          tags: [tableName, 'Relationships'],
          summary: `Get related ${relatedTable}`,
          description: `Get ${relatedTable} related to ${tableName} via ${fk.columnName}`,
          parameters: [
            {
              name: 'id',
              in: 'path',
              required: true,
              schema: { type: 'string' },
              description: `${primaryKey} of the ${tableName} record`,
            },
          ],
          responses: {
            200: {
              description: 'Successful response',
              content: {
                'application/json': {
                  schema: {
                    type: 'array',
                    items: { $ref: `#/components/schemas/${relatedSchema}` },
                  },
                },
              },
            },
            404: { description: 'Record not found' },
            500: { description: 'Server error' },
          },
        },
      };
    }

    // Reverse foreign key relationships (has-many)
    for (const rfk of tableSchema.reverseForeignKeys || []) {
      const relatedTable = rfk.referencingTable;
      const relatedSchema = this.capitalize(relatedTable);
      const path = `${basePath}/{id}/${relatedTable}`;

      // Skip if already added by foreign key
      if (spec.paths[path]) continue;

      spec.paths[path] = {
        get: {
          tags: [tableName, 'Relationships'],
          summary: `Get related ${relatedTable}`,
          description: `Get ${relatedTable} records that reference this ${tableName} via ${rfk.referencingColumn}`,
          parameters: [
            {
              name: 'id',
              in: 'path',
              required: true,
              schema: { type: 'string' },
              description: `${primaryKey} of the ${tableName} record`,
            },
            {
              name: 'limit',
              in: 'query',
              schema: { type: 'integer', default: 100 },
              description: 'Maximum number of records to return',
            },
            {
              name: 'offset',
              in: 'query',
              schema: { type: 'integer', default: 0 },
              description: 'Number of records to skip',
            },
          ],
          responses: {
            200: {
              description: 'Successful response',
              content: {
                'application/json': {
                  schema: {
                    type: 'array',
                    items: { $ref: `#/components/schemas/${relatedSchema}` },
                  },
                },
              },
            },
            404: { description: 'Record not found' },
            500: { description: 'Server error' },
          },
        },
      };
    }
  }

  /**
   * Generate filter parameters for a table
   * @param {object} tableSchema - Table schema
   * @returns {Array} Array of parameter objects
   */
  generateFilterParameters(tableSchema) {
    return tableSchema.columns.map(column => ({
      name: column.name,
      in: 'query',
      schema: this.mapColumnToSwaggerType(column),
      description: `Filter by ${column.name}`,
    }));
  }

  /**
   * Map PostgreSQL column type to Swagger type
   * @param {object} column - Column metadata
   * @returns {object} Swagger type definition
   */
  mapColumnToSwaggerType(column) {
    const typeMap = {
      integer: { type: 'integer' },
      bigint: { type: 'integer', format: 'int64' },
      smallint: { type: 'integer' },
      numeric: { type: 'number' },
      real: { type: 'number', format: 'float' },
      'double precision': { type: 'number', format: 'double' },
      boolean: { type: 'boolean' },
      'character varying': { type: 'string' },
      character: { type: 'string' },
      text: { type: 'string' },
      date: { type: 'string', format: 'date' },
      'timestamp without time zone': { type: 'string', format: 'date-time' },
      'timestamp with time zone': { type: 'string', format: 'date-time' },
      time: { type: 'string', format: 'time' },
      uuid: { type: 'string', format: 'uuid' },
      json: { type: 'object' },
      jsonb: { type: 'object' },
    };

    const swaggerType = typeMap[column.type] || { type: 'string' };

    if (column.maxLength) {
      swaggerType.maxLength = column.maxLength;
    }

    return swaggerType;
  }

  /**
   * Capitalize first letter of string
   * @param {string} str - String to capitalize
   * @returns {string} Capitalized string
   */
  capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
}

module.exports = SwaggerGenerator;
