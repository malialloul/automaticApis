import { SchemaMap, TableSchema } from '../types';

// Minimal types for generated OpenAPI pieces (keeps hover information useful)
type SwaggerProperty = { type: string; format?: string; maxLength?: number };

type OpenAPISpec = {
  openapi: string;
  info: { title: string; version: string; description?: string };
  servers: Array<{ url: string; description?: string }>;
  paths: Record<string, object>;
  components: { schemas: Record<string, { type: string; properties?: Record<string, SwaggerProperty>; required?: string[] }> };
};

export default class SwaggerGenerator {
  private connectionId: string;
  private schema: SchemaMap;

  constructor(connectionId: string, schema: SchemaMap) {
    this.connectionId = connectionId;
    this.schema = schema;
  }

  generate(): OpenAPISpec {
    const spec: OpenAPISpec = {
      openapi: '3.0.0',
      info: {
        title: `Auto-Generated API for ${this.connectionId}`,
        version: '1.0.0',
        description: 'REST API automatically generated from PostgreSQL database schema',
      },
      servers: [
        { url: '/api', description: 'API Server' },
      ],
      paths: {},
      components: { schemas: {} },
    };
    for (const [tableName, tableSchema] of Object.entries(this.schema)) {
      this.generateTableSchemas(spec, tableName, tableSchema);
      this.generateTablePaths(spec, tableName, tableSchema);
    }

    return spec;
  }

  private generateTableSchemas(spec: OpenAPISpec, tableName: string, tableSchema: TableSchema) {
    const schemaName = this.capitalize(tableName);
    const properties: Record<string, SwaggerProperty> = {};
    const required: string[] = [];
    const autoGeneratedColumns = new Set<string>();

    for (const column of tableSchema.columns) {
      properties[column.name] = this.mapColumnToSwaggerType(column);

      if (!column.isNullable && !column.default) {
        required.push(column.name);
      }

      if (column.default) {
        if (String(column.default).includes('nextval')) autoGeneratedColumns.add(column.name);
        if (String(column.default).toLowerCase().includes('now()') || String(column.default).toLowerCase().includes('current_timestamp')) autoGeneratedColumns.add(column.name);
      }

      if (tableSchema.primaryKeys?.includes(column.name) && (column.dataType === 'integer' || column.dataType === 'bigint')) {
        autoGeneratedColumns.add(column.name);
      }
    }

    spec.components.schemas[schemaName] = { type: 'object', properties };
    if (required.length > 0) spec.components.schemas[schemaName].required = required;

    const inputProperties: Record<string, SwaggerProperty> = {};
    for (const column of tableSchema.columns) {
      if (!autoGeneratedColumns.has(column.name)) inputProperties[column.name] = this.mapColumnToSwaggerType(column);
    }

    spec.components.schemas[`${schemaName}Input`] = { type: 'object', properties: inputProperties };
  }

  private generateTablePaths(spec: OpenAPISpec, tableName: string, tableSchema: TableSchema) {
    const schemaName = this.capitalize(tableName);
    const basePath = `/${this.connectionId}/${tableName}`;
    const primaryKey = tableSchema.primaryKeys[0] || 'id';

    spec.paths[basePath] = {
      get: {
        tags: [tableName],
        summary: `List all ${tableName}`,
        description: `Retrieve all records from ${tableName} with optional filtering, pagination, and sorting`,
        parameters: [
          { name: 'limit', in: 'query', schema: { type: 'integer', default: 100 }, description: 'Maximum number of records to return' },
          { name: 'offset', in: 'query', schema: { type: 'integer', default: 0 }, description: 'Number of records to skip' },
          { name: 'orderBy', in: 'query', schema: { type: 'string' }, description: 'Column name to sort by' },
          { name: 'orderDir', in: 'query', schema: { type: 'string', enum: ['ASC','DESC'], default: 'ASC' }, description: 'Sort direction' },
          ...this.generateFilterParameters(tableSchema),
        ],
        responses: { 200: { description: 'Successful response', content: { 'application/json': { schema: { type: 'array', items: { $ref: `#/components/schemas/${schemaName}` } } } } }, 500: { description: 'Server error' } },
      },
      post: {
        tags: [tableName],
        summary: `Create new ${tableName.slice(0, -1)}`,
        description: `Create a new record in ${tableName}`,
        requestBody: { required: true, content: { 'application/json': { schema: { $ref: `#/components/schemas/${schemaName}Input` } } } },
        responses: { 201: { description: 'Record created', content: { 'application/json': { schema: { $ref: `#/components/schemas/${schemaName}` } } } }, 400: { description: 'Invalid input' }, 500: { description: 'Server error' } },
      },
    };

    spec.paths[`${basePath}/{id}`] = {
      get: {
        tags: [tableName], summary: `Get ${tableName.slice(0, -1)} by ID`, description: `Retrieve a single record from ${tableName} by primary key`, parameters: [{ name: 'id', in: 'path', required: true, schema: { type: 'string' }, description: `${primaryKey} of the record` }], responses: { 200: { description: 'Successful response', content: { 'application/json': { schema: { $ref: `#/components/schemas/${schemaName}` } } } }, 404: { description: 'Record not found' }, 500: { description: 'Server error' } },
      },
      put: {
        tags: [tableName], summary: `Update ${tableName.slice(0, -1)}`, description: `Update a record in ${tableName}`, parameters: [{ name: 'id', in: 'path', required: true, schema: { type: 'string' }, description: `${primaryKey} of the record` }], requestBody: { required: true, content: { 'application/json': { schema: { $ref: `#/components/schemas/${schemaName}Input` } } } }, responses: { 200: { description: 'Record updated', content: { 'application/json': { schema: { $ref: `#/components/schemas/${schemaName}` } } } }, 404: { description: 'Record not found' }, 400: { description: 'Invalid input' }, 500: { description: 'Server error' } },
      },
      delete: {
        tags: [tableName], summary: `Delete ${tableName.slice(0, -1)}`, description: `Delete a record from ${tableName}`, parameters: [{ name: 'id', in: 'path', required: true, schema: { type: 'string' }, description: `${primaryKey} of the record` }], responses: { 200: { description: 'Record deleted' }, 404: { description: 'Record not found' }, 500: { description: 'Server error' } },
      },
    };

    this.generateRelationshipPaths(spec, tableName, tableSchema, basePath);
  }

  private generateRelationshipPaths(spec: OpenAPISpec, tableName: string, tableSchema: TableSchema, basePath: string) {
    const primaryKey = tableSchema.primaryKeys[0] || 'id';

    for (const fk of tableSchema.foreignKeys || []) {
      const relatedTable = fk.foreignTable;
      const relatedSchema = this.capitalize(relatedTable);
      const path = `${basePath}/{id}/${relatedTable}`;

      spec.paths[path] = {
        get: {
          tags: [tableName, 'Relationships'],
          summary: `Get related ${relatedTable}`,
          description: `Get ${relatedTable} related to ${tableName} via ${fk.columnName}`,
          parameters: [{ name: 'id', in: 'path', required: true, schema: { type: 'string' }, description: `${primaryKey} of the ${tableName} record` }],
          responses: { 200: { description: 'Successful response', content: { 'application/json': { schema: { type: 'array', items: { $ref: `#/components/schemas/${relatedSchema}` } } } } }, 404: { description: 'Record not found' }, 500: { description: 'Server error' } },
        },
      };
    }

    for (const rfk of tableSchema.reverseForeignKeys || []) {
      const relatedTable = rfk.referencingTable;
      const relatedSchema = this.capitalize(relatedTable);
      const path = `${basePath}/{id}/${relatedTable}`;
      if (spec.paths[path]) continue;
      spec.paths[path] = {
        get: {
          tags: [tableName, 'Relationships'], summary: `Get related ${relatedTable}`, description: `Get ${relatedTable} records that reference this ${tableName} via ${rfk.referencingColumn}`, parameters: [{ name: 'id', in: 'path', required: true, schema: { type: 'string' }, description: `${primaryKey} of the ${tableName} record` }, { name: 'limit', in: 'query', schema: { type: 'integer', default: 100 }, description: 'Maximum number of records to return' }, { name: 'offset', in: 'query', schema: { type: 'integer', default: 0 }, description: 'Number of records to skip' }], responses: { 200: { description: 'Successful response', content: { 'application/json': { schema: { type: 'array', items: { $ref: `#/components/schemas/${relatedSchema}` } } } } }, 404: { description: 'Record not found' }, 500: { description: 'Server error' } },
        },
      };
    }
  }

  private generateFilterParameters(tableSchema: TableSchema): Array<{ name: string; in: 'query'; schema: SwaggerProperty; description: string }> {
    return tableSchema.columns.map(column => ({ name: column.name, in: 'query', schema: this.mapColumnToSwaggerType(column), description: `Filter by ${column.name}` }));
  }

  private mapColumnToSwaggerType(column: { dataType?: string; maxLength?: number }): SwaggerProperty {
    const typeMap: Record<string, SwaggerProperty> = {
      integer: { type: 'integer' },
      bigint: { type: 'integer', format: 'int64' },
      smallint: { type: 'integer' },
      numeric: { type: 'number' },
      real: { type: 'number', format: 'float' },
      'double precision': { type: 'number', format: 'double' },
      boolean: { type: 'boolean' },
      'character varying': { type: 'string' },
      character: { type: 'string' },
      text: { type: 'string' },
      date: { type: 'string', format: 'date' },
      'timestamp without time zone': { type: 'string', format: 'date-time' },
      'timestamp with time zone': { type: 'string', format: 'date-time' },
      time: { type: 'string', format: 'time' },
      uuid: { type: 'string', format: 'uuid' },
      json: { type: 'object' },
      jsonb: { type: 'object' },
    } as const;

    const swaggerType = (column.dataType && (typeMap as Record<string, SwaggerProperty>)[column.dataType]) || { type: 'string' };

    if (typeof column.maxLength === 'number') return { ...swaggerType, maxLength: column.maxLength };
    return swaggerType;
  }

  private capitalize(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
}
